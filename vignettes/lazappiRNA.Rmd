---
title: "lazappiRNA"
author: "Luke Zappia"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{lazappiRNA}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r global_options, include = FALSE}
# Default RMarkdown options
# Changing these will change them for all chunks unless otherwise set
knitr::opts_chunk$set(
                        autodep        = TRUE,
                        cache          = FALSE,
                        cache.comments = TRUE,
                        collapse       = TRUE,
                        comment        = "##",
                        #dev            = "png",
                        echo           = TRUE,
                        error          = FALSE,
                        fig.width      = 7,
                        fig.height     = 5,
                        fig.align      = "center",
                        highlight      = TRUE,
                        include        = TRUE,
                        message        = FALSE,
                        prompt         = FALSE,
                        results        = "markup",
                        size           = "normalsize",
                        strip.white    = TRUE,
                        tidy           = FALSE,
                        tidy.opts      = NULL,
                        warning        = FALSE
               )
```

Welcome!
========

Welcome to lazappiRNA! Many studies across the life science now make use of
RNA-seq to investigate gene products. These experiments can provide high-quality
measurements of gene expression across a wide dynamic range, and in contrast to
microarracy experiments do not require probes to be designed for specific
regions.

Perhaps the most common analysis pipeline for RNA-seq data is to perform
quality control, align reads to a reference genome, summarise reads against a
known annotation and perform differential expression testing. The aim of this
process is to identify genes or transcripts that have significantly different 
activity levels under some treatment condition (disease, drug, knockout, 
environment...) compared to a control. Further analysis attempts to investigate 
the biological implications of these changes in regulation.

Multiple methods exist for each of these steps. This package takes a matrix of
summarised counts for a group of samples and provides a unified interface for
differential expression testing (using edgeR, DESeq, DESeq2 and limma-voom) and
functional analysis. The aim is allow simultaneous analysis using multiple
packages including robust quality control, easily comparable visulisations and
combination of results.

Before we get started let's load some packages we will need:

```{r libraries}
library(lazappiRNA)

# Plotting
library(ggplot2)

# RNA-seq
library(HTSFilter)
```

Data
====

For this vignette we are going to make use of data from Sultan et al. available
from the _HTSFilter_ package. This dataset contains two biological replicates
from a human embryonic kidney and B cell line. The raw read count and phenotype
table are available as part of the ReCount online resource.

We have alread load _HTSFilter_ so we can start by attaching the data in 
`sultan`. Other information is available but we are just interested in the 
matrix of counts and the groups for each sample:

```{r data}
data("sultan")

counts <- exprs(sultan)
groups <- pData(sultan)$cell.line

rm(sultan)

groups

head(counts)
```

The matrix of counts and factor specifying the group of each sample are going
to be the main input for our analysis.

Exploration
===========

Before starting our analysis we should begin by exploring our data. This allows
us to spot anything that is obviously wrong and provides a baseline we can make
comparisons to later. Let's have a look a the count density.

```{r count-density}
countDensity(counts)
```

All of the plotting function in lazappiRNA return _ggplot2_ objects. These can
be easily modified, for example if we prefer the black and white theme and 
would like a title:

```{r count-density-bw}
countDensity(counts) + theme_bw() + ggtitle("Count Densities")
```

Here we can see that the distribution is both over a large range and heavily
skewed towards low values. For this reason transformed version of counts are
commonly used for plotting, such as: 

$$
\begin{aligned}
    y = log_2(K + 1)
\end{aligned}
$$

More sophisted transformations are provided by the differential expression
packages such as the Variance Stabilising Transformation (_DESeq_),
regularised-log (_DESeq2_) and log Counts Per Million (_edgeR_). lazappiRNA
is capable of performing each of these.

```{r transform}
transformed <- transformCounts(counts,
                               methods = c("log", "vst", "rlog", "logCPM"))

names(transformed)

head(transformed[["log"]])
```

The result of this function is a list of matrices where each is transformed
using one of the specifed methods. We can now use the `listDensity` function
to plot each of these. Again the result is a list but now each item is a 
_ggplot2_ object containing a density plot. An additional item has been added
which holds the combined plot.

```{r densities}
densities <- listDensity(transformed)

names(densities)

densities$combined
```

Similar function exist for producing boxplots.

```{r boxplots}
boxplots <- listBoxplots(transformed)

boxplots$combined
```

Both sets of plots can be helpful for exploring a dataset. The boxplots clearly
show the expression quartiles and the presence of outlier genes. The density
plots give more detail about the distribution, for example showing any
bi-modality. It is also possible to see the effect of _DESeq2's_ regularised 
log transformation as it removes the peak at lower expression levels.

Pairwise MA plots show the difference in expression for genes in two samples
compared to the average expression of the two samples.

```{r ma-plots}
ma.plots <- listCountMA(transformed)

ma.plots$combined
```

Here we can see the reproducability between samples and whether normalisation
is needed. Genes that are similar in the two samples appear around the $y = 0$
line (blue) and a lowess fit (red) shows trends in bias related to mean
expression.

With more samples the numbers of these plot grows quickly and it may be more
useful to select a single transformation or some samples of interest.

```{r single-ma}
countMA(transformed$log)
```

For this dataset the results look pretty good. The plot are centered around
$y = 0$ and the samples from the same cell-types have reduced variance.

To explore the similarites and dissimilarities between samples looking at a
clustered heatmap of the between sample distances can be helpful. The
`countHeatmap` function (and the related `listHeatmaps`) can be used to produce
these plots. By providing the vector of groups these can be included as labels
on the y-axis. As dendrograms indicating the clustering are included the result
is a list of _ggplot2_ objects instead of a single plot. The `showHeatmap`
function can assemble these into a single image.

```{r heatmaps, fig.height = 7}
heatmap <- countHeatmap(transformed$log, groups = groups)

names(heatmap)

showHeatmap(heatmap)
```

Principal component analysis (PCA) can also be useful for visualising the
similarities between samples, in particular identifying outliers and batch \
effects. PCA reduces the dimensionality of a dataset to identify the directions
with greatest variance. Plotting samples onto the reduced dimensions allows
quick comparisons.

```{r PCA}
PCA <- listPCA(transformed, top = 500, groups = groups)

PCA$combined
```

Since PCA can be problematic with very high-dimensional data we select the
top 500 most variable genes, and provide groups to colour the labels. As we are
looking for differentially expressed genes we hope to see a clear separation
between the two groups, as is the case along PC1.

Multidimenionsal scaling (MDS) provides an alternative to PCA that aims to
visually represent the distances amongst a set of samples. Genes can be selected
based on "common" deviations across all samples (similar to what was done with
PCA) or "pairwise" between each pair of samples.

```{r MDS}
MDS <- listMDS(transformed, top = 500, group = groups, selection = "pairwise")

MDS$combined
```

In this simple example the PCA and MDS plots are highly similar but with more
complex datasets it may be worthwhile examining both.

Objects
=======

Each differential expression package makes use of its own objects. A function
is provided to easily convert a matrix of counts into the appropriate objects
for multiple packages, returned as a list.

```{r objects}
objects <- counts2Objects(counts, groups,
                          methods = c("edgeR", "DESeq", "DESeq2", "voom"))

names(objects)

for(object in objects) {
    print(class(object))
}
```

**NOTE:** It is important that the names of this list are not changed as they
will be used by following functions to identify which method to apply.

Normalistion
============

Each package has its own normalisation procedures. Here we use the `listNorm`
function to normalise our list of objects.

```{r normalise}
normalised <- listNorm(objects)
```

Please read the documentation for the packages you plan to use to properly
undstand what is been done in this process.

Testing
=======

Once the data has been normalised we can test for differential expression. We 
first need to assign the groups we would like to test as `group1`, the
reference or control, and `group1` the treament. The control group should always 
be whichever group was defined as the lowest level of the `groups` factor. Again
a list function allows use to perform all methods simultaneously.

```{r test}
group1 <- "HEK293T"
group2 <- "Ramos B cell"

tested <- listTest(normalised, group1, group2)
```

Session Info
============

```{r sessionInfo}
sessionInfo()
```

